## 1.1 理解 proc_run 函数和它调用的函数如何完成进程切换的
请在实验报告中简要说明你对 proc_run 函数的分析。并回答如下问题：
在本实验的执行过程中，创建且运行了几个内核线程？
语句 local_intr_save(intr_flag);....local_intr_restore(intr_flag); 在这里有何作用? 请说明理由

---

<br>

### 1. 简要说明对 proc_run 函数的分析

该函数位于`kern\process\proc.c`，函数体如下：

```c
// proc_run - make process "proc" running on cpu
// NOTE: before call switch_to, should load  base addr of "proc"'s new PDT
void
proc_run(struct proc_struct *proc) {
    if (proc != current) {
        bool intr_flag;
        struct proc_struct *prev = current, *next = proc;
        local_intr_save(intr_flag);
        {
            current = proc;
            load_esp0(next->kstack + KSTACKSIZE);
            lcr3(next->cr3);
            switch_to(&(prev->context), &(next->context));
        }
        local_intr_restore(intr_flag);
    }
}
```

该函数完成的功能是进行进程切换，将proc指向的进程调入cpu中运行。
<a href="函数的执行逻辑">函数的执行逻辑为：</a>

1. 若proc不是当前进程，调用`local_intr_save`禁止中断
    > `local_intr_save`调用`__intr_save`，`__intr_save`调用`intr_disable`，`intr_disable`的功能为disable irq interrupt，即禁止中断
   
2. 将当前运行的进程的指针current指向proc进程，修改esp0，加载页表项（完成进程间的页表切换），进行线程的执行现场切换
    > - 根据
    > ```c
    > // current proc 
    > struct proc_struct *current = NULL; 
    > ```
    > current指针是当前进程的指示指针，被初始化为NULL
    > - 追踪`load_esp0`函数，其将
    > ```c
    > ts_esp0;      // stack pointers and segment selectors
    > ```
    > 指向`next->kstack + KSTACKSIZE`，即寄存器存放当前线程proc的栈顶指针
    > - 修改页表项
    > ```c
    > uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
    > ```
    > - 线程的执行现场切换
    > ```c
    > void switch_to(struct context *from, struct context *to);
    > ```
    > switch_to具体实现位于switch.S
3. 允许中断
   > `local_intr_restore`调用`__intr_restore`，`__intr_restore`调用`intr_enable`，`intr_enable`的功能为enable irq interrupt，即允许中断

<br>

### 2. 在本实验的执行过程中，创建且运行了几个内核线程？
查看`proc_init`函数，可知创建且运行了`idleproc`和`initproc`两个内核线程。
- `idleproc`进程：ucore第一个内核进程，完成内核中各个子系统的初始化，之后立即调度，执行其他进程或线程。该内核线程的工作就是不停地查询，看是否有其他内核线程可以执行了，如果有，马上让调度器选择那个内核线程执行。`idleproc`内核线程是在ucore 操作系统没有其他内核线程可执行的情况下才会被调用。
- `initproc`进程：用于完成实验的功能的内核线程


<br>

### 3. 语句 local_intr_save(intr_flag);....local_intr_restore(intr_flag); 在这里有何作用? 请说明理由

禁止中断和允许中断，以免进程切换时其他进程再进行调度。

`local_intr_save(intr_flag);`：禁止中断
`local_intr_save`调用`__intr_save`，`__intr_save`调用`intr_disable`，`intr_disable`的功能为disable irq interrupt，即禁止中断

`local_intr_restore(intr_flag);`：允许中断
`local_intr_restore`调用`__intr_restore`，`__intr_restore`调用`intr_enable`，`intr_enable`的功能为enable irq interrupt，即允许中断

详细请看点击<a name="函数的执行逻辑">函数的执行逻辑</a>，查看位于1. 简要说明对 proc_run 函数的分析中的内容。

