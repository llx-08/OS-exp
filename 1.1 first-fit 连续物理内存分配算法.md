## 1.1 实现 first-fit 连续物理内存分配算法（需要编程）
在实现 first fit 内存分配算法的回收函数时，要考虑地址连续的空闲块之间的合并操作。提示:
在建立空闲页块链表时，需要按照空闲页块起始地址来排序，形成一个有序的链表。可能会修改default_pmm.c 中的 default_init，default_init_memmap，default_alloc_pages，default_free_pages 等相关函数。请仔细查看和理解 default_pmm.c 中的注释。请在实验报告中简要说明你的设计实现过程。


1. 查看Page的结构：
    ```c
    /* *
    * struct Page - Page descriptor structures. Each Page describes one
    * physical page. In kern/mm/pmm.h, you can find lots of useful functions
    * that convert Page to other data types, such as phyical address.
    * */
    struct Page {
        int ref;                        // 页的引用次数 page frame's reference counter
        uint32_t flags;                 // 该页是否可分配 array of flags that describe the status of the page frame
        unsigned int property;          // 还有多少空闲块可用 the num of free block, used in first fit pm manager
        list_entry_t page_link;         // 页首地址 free list link
        list_entry_t pra_page_link;     // used for pra (page replace algorithm)
        uintptr_t pra_vaddr;            // used for pra (page replace algorithm)
    };
    ```
    和相关方法
    ```c
    /* Flags describing the status of a page frame */
    #define PG_reserved                 0       // the page descriptor is reserved for kernel or unusable
    #define PG_property                 1       // the member 'property' is valid

    #define SetPageReserved(page)       set_bit(PG_reserved, &((page)->flags))
    #define ClearPageReserved(page)     clear_bit(PG_reserved, &((page)->flags))
    #define PageReserved(page)          test_bit(PG_reserved, &((page)->flags))
    // 设置Page是否分配的状态
    #define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))  // 空闲
    #define ClearPageProperty(page)     clear_bit(PG_property, &((page)->flags))    //非空闲
    #define PageProperty(page)          test_bit(PG_property, &((page)->flags))

    ```
    特别要注意的是，SetPageProperty、ClearPageProperty、PageProperty这三个方法设置的是flags位而不是property位。想想也知道，property表示的是空闲块数目，怎么可能用两个状态就表示得了。但是这个取名实在太坑了，让我们总是混淆，错用这些方法将property位置0。


2. 查看list.h文件，了解list所具有的属性和方法

3. 修改
-  `default_init`: 

    查看代码可知free_list与nr_free的定义
    ```c
    free_area_t free_area;

    #define free_list (free_area.free_list)     //空闲块的头
    #define nr_free (free_area.nr_free) //空闲块的总数
    ```

    根据提示和逻辑，不需要修改

    ```c
    static void
    default_init(void) {
        list_init(&free_list);
        nr_free = 0;
    }
    ```

- `default_init_memmap`: 
    该函数对每一块的第一个page进行初始化。
    访问每个page的方式为用块的第一个page的地址加上偏移量。
    具体实现设计见代码注释。
    ```c
    static void
    default_init_memmap(struct Page *base, size_t n) {
        assert(n > 0);
        struct Page *p = base;

        // 遍历所有空闲page：
        // 1. 将描述空闲块数目的property置零(故该成员变量只有在整个空闲块的第一个page中才有意义)->之后要特别注意这个，我们之前因为逻辑发生了混淆，给每个page的property都赋值了,
        // 2. 清空这些物理页的引用计数ref,
        // 3. 设置flags = PG_property = 1将物理页标记为空闲可分配状态
        for (; p != base + n; p ++) {
            assert(PageReserved(p));
            // flags: 物理页的状态：空闲与否
            // property: 描述空闲块的数目, used in first fit pm manager
            p->flags = p->property = 0; 
            set_page_ref(p, 0);        
        }

        // 对空闲块的第一个page进行初始化（完成初始化空闲页信息的工作）：
        // 1. 设置块内共有空闲page = n
        // 2. 更新所有空闲page数量的全局变量nr_free = n
        // 3. 将该空闲块插入到空闲内存块链表中(使用块内第一个page的首部地址作为块地址)
        // SetPageProperty在memelayout.h中定义为: set_bit(PG_property, &((page)->flags))
        // 即令flags = PG_property = 1，表示该页可分配
        SetPageProperty(base);
        list_add_before(&free_list, &(p->page_link)); // 地址由低向高增长
        base->property = n;
        
        nr_free += n;   // 设置当前空闲page总数为n
        // list_add_before(&free_list, &(base->page_link));    // 地址由低向高增长
        cprintf("[default_init_memmap]\n");
    }
    ```
- `default_alloc_pages`:


    根据提示，查看`list_next`, `le2page`, `list_add_before`三个函数。
    `list_next`、`list_add_before`位于`list.h`中：
    
    - `list_next`: 将list内的指针移向下一个块，返回的是下一个块的首地址，也就是下一个块的第一个page的地址
    - `list_add_before`: 
        查看`__list_add`函数可得，传入的参数\*listelm为要被在前面插入块的块，\*elm为要插入的块
        ```c
        static inline void
        list_add_before(list_entry_t *listelm, list_entry_t *elm) {
            __list_add(elm, listelm->prev, listelm);
        }
        static inline void
        // 将某个块插入list特定的位置的工具函数
        __list_add(list_entry_t *elm, list_entry_t *prev, list_entry_t *next) {
            prev->next = next->prev = elm;
            elm->next = next;
            elm->prev = prev;
        }
        ```

    - `le2page`: 
        是一个把list entry转为page的函数，也就是特定位置的块转换为page结构来使用。当要进行块内page遍历的时候将用到这个函数。
        ```c
        // convert list entry to page
        #define le2page(le, member)                 \
            to_struct((le), struct Page, member)
        ```
- `default_free_pages`:
    该函数用来释放指定的某一page开始的若干个连续pages。
    具体实现设计见代码注释。
    ```c
    static void
    default_free_pages(struct Page *base, size_t n) {
        // (5.1) According to the base address of the withdrawed blocks, 
        // search the freelist for its correct position (with address from low to high), 
        // and insert the pages. (May use `list_next`, `le2page`, `list_add_before`)

        assert(n > 0);

        struct Page *p = base;
        
        // 检查页flags是否正确，将reserve（保留）和ref（引用）位 置为0
        for (; p != base + n; p ++) {
            // 确定这些页是已经被保留/占用了的
            assert(!PageReserved(p) && !PageProperty(p));
            p->flags = 0;
            set_page_ref(p, 0);
        }
        base->property = n;
        SetPageProperty(base);

        list_entry_t *le = list_next(&free_list);
        list_entry_t *nxt = &free_list;
        while (le != &free_list) {
            // 向高地址合并
            p = le2page(le, page_link);
            le = list_next(le);
            if (base + base->property == p) {
                base->property += p->property;
                // 无空闲块了
                p->property = 0;
                // 设置为非空闲，flags=1
                ClearPageProperty(p);
                nxt = (p->page_link).next;
                list_del(&(p->page_link));
            }
            // 向低地址合并
            else if (p + p->property == base) {
                p->property += base->property;
                base->property = 0;
                ClearPageProperty(base);
                base = p;
                nxt = (p->page_link).next;
                list_del(&(p->page_link));
            }
            else if (base + base->property < p && nxt == NULL)
            {
                nxt = le;
                break;
            }
        }
        nr_free += n;
        list_add_before(nxt, &(base->page_link));
    }
    ```
