## 1.1 完成读写文件操作的实现
首先了解 ucore 文件系统的层次结构，可以从自底向上也可以自顶向下，理解打开文件和读写文件的过程，并补充 sfs_indoe.c 中 sfs_io_nolock 读文件中数据的实现代码。并在实验报告中分析读写文件系统调用的代码执行路径和其中涉及到的数据结构。

---

<br>

`sfs_indoe.c`位于`\kern\fs\sfs`，功能为（Rd/Wr a file content from offset position to offset + length  disk blocks<-->buffer (in memroy)）

根据实验文档，可以了解到ucore模仿了UNX的文件系统设计，文件系统架构主要由四部分组成：
- 通用文件系统访问接口层:该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得 corel内核的文件系统服务。
- 文件系统抽象层：向上提供一个一致的接口给内核其他部分(文件系统相关的系统调用实现模块和其他内核功能模块)访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。
- Simple FS文件系统层：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口- 外设接口层：向上提供 device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。

<br>

## 1. 补充 sfs_indoe.c 中 sfs_io_nolock 读文件中数据的实现代码

其实实验包里已经给出了
```c
/*  
 * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks<-->buffer (in memroy)
 * @sfs:      sfs file system
 * @sin:      sfs inode in memory
 * @buf:      the buffer Rd/Wr
 * @offset:   the offset of file
 * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght
 * @write:    BOOL, 0 read, 1 write
 */
static int
sfs_io_nolock(struct sfs_fs *sfs, struct sfs_inode *sin, void *buf, off_t offset, size_t *alenp, bool write) {
    struct sfs_disk_inode *din = sin->din;
    assert(din->type != SFS_TYPE_DIR);
    off_t endpos = offset + *alenp, blkoff;
    *alenp = 0;
    // calculate the Rd/Wr end position
    if (offset < 0 || offset >= SFS_MAX_FILE_SIZE || offset > endpos) {
        return -E_INVAL;
    }
    if (offset == endpos) {
        return 0;
    }
    if (endpos > SFS_MAX_FILE_SIZE) {
        endpos = SFS_MAX_FILE_SIZE;
    }
    if (!write) {
        if (offset >= din->size) {
            return 0;
        }
        if (endpos > din->size) {
            endpos = din->size;
        }
    }

    int (*sfs_buf_op)(struct sfs_fs *sfs, void *buf, size_t len, uint32_t blkno, off_t offset);
    int (*sfs_block_op)(struct sfs_fs *sfs, void *buf, uint32_t blkno, uint32_t nblks);
    if (write) {
        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;
    }
    else {
        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;
    }

    int ret = 0;
    size_t size, alen = 0;
    uint32_t ino;
    uint32_t blkno = offset / SFS_BLKSIZE;          // The NO. of Rd/Wr begin block
    uint32_t nblks = endpos / SFS_BLKSIZE - blkno;  // The size of Rd/Wr blocks

  //LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file
    /*
     * (1) If offset isn't aligned with the first block, Rd/Wr some content from offset to the end of the first block
     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op
     *               Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)
     * (2) Rd/Wr aligned blocks 
     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op
     * (3) If end position isn't aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block
     *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op    
    */
    if ((blkoff = offset % SFS_BLKSIZE) != 0)
    {
        //读取第一部分的数据
        //计算第一个数据块的大小
        size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);
        if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino)) != 0)
     {
         //先找到内存文件索引对应的block的编号ino
            goto out;
        }
        if ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != 0)
    {
            goto out;
        }
        //完成实际的读写操作
        alen += size;
        if (nblks == 0) 
    {
            goto out;
        }
        buf += size, blkno ++, nblks --;
    }
    //读取中间部分的数据，分解成size大小，一块一块的读直至读完
    size = SFS_BLKSIZE;
    while (nblks != 0) 
    {
        if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino)) != 0) 
    {
            goto out;
        }
        if ((ret = sfs_block_op(sfs, buf, ino, 1)) != 0) 
    {
            goto out;
        }
        alen += size, buf += size, blkno ++, nblks --;
    }
    //读取第三部分的数据
    if ((size = endpos % SFS_BLKSIZE) != 0) 
    {
        if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino)) != 0) 
    {
            goto out;
        }
        if ((ret = sfs_buf_op(sfs, buf, size, ino, 0)) != 0) 
    {
            goto out;
        }
        alen += size;
    }
out:
    *alenp = alen;
    if (offset + alen > sin->din->size) {
        sin->din->size = offset + alen;
        sin->dirty = 1;
    }
    return ret;
}
```

<br>

## 2. 分析读写文件系统调用的代码执行路径和其中涉及到的数据结构

文件系统的访问处理过程：假如应用程序操作文件(打开/创建/删除/读写)，首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统(比如SFS文件系统)，具体文件系统(Simple FS文件系统层)把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。结合用户态写文件函数 write的整个执行过程，可以比较清楚地看出 ucore文件系统架构的层次和依赖关系。

具体流程如下：
1. 通用文件访问接口层的处理流程
  首先进入通用文件访问接口层的处理流程，即进一步调用如下用户态函数：`open->sys_open->syscall`，从而引起系统调用进入到内核态。到了内核态后，通过中断处理例程，会调用到`sys_open`内核函数，并进一步调用`sysfile_open`内核函数。到了这里，需要把位于用户空间的字符串"/test/testfile"拷贝到内核空间中的字符串path中，并进入到文件系统抽象层的处理流程完成进一步的打开文件操作中。

2. 文件系统抽象层的处理流程
    - 分配一个空闲的file数据结构变量file在文件系统抽象层的处理中，首先调用的是`file_open`函数，它要给这个即将打开的文件分配一个file数据结构的变量，这个变量其实是当前进程的打开文件数组`current->fs_struct->filemap[]`中的一个空闲元素（即还没用于一个打开的文件），而这个元素的索引值就是最终要返回到用户进程并赋值给变量fd1。到了这一步还仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。
    为此需要进一步调用`vfs_open`函数来找到path指出的文件所对应的基于inode数据结构的VFS索引节点node。`vfs_open`函数需要完成两件事情：通过`vfs_lookup`找到path对应文件的inode；调用`vop_open`函数打开文件。
    - 找到文件设备的根目录/的索引节点需要注意，这里的`vfs_lookup`函数是一个针对目录的操作函数，它会调用`vop_lookup`函数来找到SFS文件系统中的/test目录下的testfile文件。为此，`vfs_lookup`函数首先调用`get_device`函数，并进一步调用`vfs_get_bootfs`函数来找到根目录/对应的inode。这个inode就是位于vfs.c中的inode变量bootfs_node。这个变量在init_main函数（位于kern/process/proc.c）执行时获得了赋值。
    - 找到根目录/下的test子目录对应的索引节点，在找到根目录对应的inode后，通过调用vop_lookup函数来查找/和test这两层目录下的文件testfile所对应的索引节点，如果找到就返回此索引节点。
    - 把file和node建立联系。完成第3步后，将返回到`file_open`函数中，通过执行语句`file->node=node`，就把当前进程的`current->fs_struct->filemap[fd]`（即file所指变量）的成员变量node指针指向了代表/test/testfile文件的索引节点node。这时返回fd。经过重重回退，通过系统调用返回，用户态的`syscall->sys_open->open->safe_open`等用户函数的层层函数返回，最终把把fd赋值给fd1。自此完成了打开文件操作。

3. SFS文件系统层的处理流程
  在`sfs_inode.c`中的`sfs_node_dirops`变量定义了`.vop_lookup = sfs_lookup`:

```c
    static int sfs_lookup(struct inode *node, char *path, struct inode **node_store) {
    struct sfs_fs *sfs = fsop_info(vop_fs(node), sfs);
    assert(*path != '\0' && *path != '/');    //以“/”为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。
    vop_ref_inc(node);
    struct sfs_inode *sin = vop_info(node, sfs_inode);
    if (sin->din->type != SFS_TYPE_DIR) {
        vop_ref_dec(node);
        return -E_NOTDIR;
    }
    struct inode *subnode;
    int ret = sfs_lookup_once(sfs, sin, path, &subnode, NULL);  
    //循环进一步调用sfs_lookup_once查找以“test”子目录下的文件“testfile1”所对应的inode节点。

    vop_ref_dec(node);
    if (ret != 0) {  
        return ret;
    }
    *node_store = subnode;  //当无法分解path后，就意味着找到了需要对应的inode节点，就可顺利返回了。
    return 0;
    }
```

`sfs_lookup`有三个参数：node，path，node_store。其中node是根目录/所对应的inode节点；path是文件testfile的绝对路径/test/testfile，而node_store是经过查找获得的testfile所对应的inode节点。
`sfs_lookup`函数以/为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。在本例中是分解出test子目录，并调用`sfs_lookup_once`函数获得test子目录对应的inode节点subnode，然后循环进一步调用`sfs_lookup_once`查找以test子目录下的文件testfile1所对应的inode节点。当无法分解path后，就意味着找到了testfile1对应的inode节点，就可顺利返回了。
`sfs_lookup_once`将调用`sfs_dirent_search_nolock`函数来查找与路径名匹配的目录项，如果找到目录项，则根据目录项中记录的inode所处的数据块索引值找到路径名对应的SFS磁盘inode，并读入SFS磁盘inode对的内容，创建SFS内存inode。

```c
    static int sfs_lookup_once(struct sfs_fs *sfs, struct sfs_inode *sin, const char *name, struct inode **node_store, int *slot) {
    int ret;
    uint32_t ino;
    lock_sin(sin);
    {   // find the NO. of disk block and logical index of file entry
        ret = sfs_dirent_search_nolock(sfs, sin, name, &ino, slot, NULL);
    }
    unlock_sin(sin);
    if (ret == 0) {
        // load the content of inode with the the NO. of disk block
        ret = sfs_load_inode(sfs, node_store, ino);
    }
    return ret;
    }
```

其中涉及的关键数据结构有：

1. 超级块(Superblock),它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间
```c
/*
 * On-disk superblock
 */
struct sfs_super {
    uint32_t magic;                                 /* magic number, should be SFS_MAGIC */
    uint32_t blocks;                                /* # of blocks in fs */
    uint32_t unused_blocks;                         /* # of unused blocks in fs */
    char info[SFS_MAX_INFO_LEN + 1];                /* infomation for sfs  */
};
```
2. 索引节点(inode):它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。
```c
/*
 * A struct inode is an abstract representation of a file.
 *
 * It is an interface that allows the kernel's filesystem-independent 
 * code to interact usefully with multiple sets of filesystem code.
 */

/*
 * Abstract low-level file.
 *
 * Note: in_info is Filesystem-specific data, in_type is the inode type
 *
 * open_count is managed using VOP_INCOPEN and VOP_DECOPEN by
 * vfs_open() and vfs_close(). Code above the VFS layer should not
 * need to worry about it.
 */
struct inode {
    union {
        struct device __device_info;
        struct sfs_inode __sfs_inode_info;
    } in_info;
    enum {
        inode_type_device_info = 0x1234,
        inode_type_sfs_inode_info,
    } in_type;
    int ref_count;
    int open_count;
    struct fs *in_fs;
    const struct inode_ops *in_ops;
};
```

3. 目录项(dentry):它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项(注:一系列目录项形成目录/文件路径)。它的作用范围是整个OS空间。对于SFS而言, inode(具体为 struct sfs_dlsk_ inode)对应于物理磁盘上的具体对象, dentry(具体为 Istruct sfs_disk_ entry)是一个内存实体,其中的ino成员指向对应的 inode number,另外一个成员是file name(文件名) 
```c
/* file entry (on disk) */
struct sfs_disk_entry {
    uint32_t ino;                                   /* inode number */
    char name[SFS_MAX_FNAME_LEN + 1];               /* file name */
};
```

4. 文件(file),它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识,文件读写的位置,文件引用情况等信息。它的作用范围是某一具体进程。

