## 1.2 实现“寻找虚拟地址对应的页表项”函数（需要编程）
通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的get_pte 函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全get_pte 函数 in kern/mm/pmm.c，实现其功能。请仔细查看和理解get_pte 函数中的注释

---

观察函数签名:

```c
pte_t *
get_pte(pde_t *pgdir, uintptr_t la, bool create)
```

根据指导书:

- 返回类型pte_t全称为page table entry，返回值为二级页表的表项。
- 传入参数
  - pde_t全称为page directory entry，为一级页表的表项，pgdir给出一级页表起始地址。
  - uintptr_t la表示为线性地址（linear address），由于段式管理只做直接映射，所以它也是逻辑地址。
  - bool类型参数create，表示是否为一个没有对应的二级页表的项分配一个二级页表

get_pte要实现从一级页表到二级页表的映射。具体逻辑为，查找二级页表项，如果页表项存在，做一级到二级页表的地址映射，返回二级页表表项的地址。
如果对应的二级页表不存在，若传入的create==0，则不为此项分配二级页表，get_pte返回NULL；若create!=0，则通过alloc_page申请一个新的物理页，再在一级页表中添加页目录项指向表示二级页表的新物理页。

根据Below comments中的提示，对页表进行操作需要设置用户权限以保证安全性。从mmu.h中获取从一级页表到二级页表的映射时设置的控制位信息：

DEFINEs:
*   `PTE_P`           0x001  
    -page table/directory entry flags bit : Present                 
    页目录存在位
    0: 缺少对应的页表空间->可通过alloc_page分配一个物理页给页表
  
*   `PTE_W`           0x002                   
    page table/directory entry flags bit : Writeable
    物理内存页内容可写


*   `PTE_U`           0x004                   
    page table/directory entry flags bit : User can access
    用户态的软件可以读取对应地址的物理内存页内容

`PTE_USER(PTE_U | PTE_W | PTE_P)`表示其中任一项成立的情况

阅读提示信息中的参考函数：
- PDX(la)：获得虚地址la在PDE中的索引号
- KADDR(pa) : 物理地址到虚地址的转换
- set_page_ref(page,1) : 设置页被一次引用
- page2pa(page): 获得该页对应的物理地址
- struct Page * alloc_page() : 分配页
- memset(void *s, char c, size_t n) : 将指针s指向的n bytes的内存设为c



```c
pte_t *
get_pte(pde_t *pgdir, uintptr_t la, bool create) {
    // (1) find page directory entry
    pde_t *pdep = &pgdir[PDX(la)];
    if (!(*pdep & PTE_P)) // (2) check if entry is not present
    {
        if (create) // (3) check if creating is needed
        {
            // then alloc page for page table
            struct Page *page = alloc_page();
            // 没有空闲页
            if (page == NULL)
            {
                // (8) return page table entry NULL
                return NULL;
            }
            // (4) set page reference
            set_page_ref(page, 1);
            // (5) get linear address of page
            uintptr_t pa = page2pa(page);
            // (6) clear page content using memset,将PGSIZE的内存设为0
            memset(KADDR(pa), 0, PGSIZE);
            // (7) set page directory entry's permission
            *pdep = pa | PTE_USER;
        }
        else
        {
            // (8) return page table entry NULL
            return NULL;
        }
    }
    uintptr_t *pt_va = KADDR(PDE_ADDR(*pdep));
    //cprintf("here \n");
    pte_t *ptep = &pt_va[PTX(la)];
    // (8) return page table entry
    return ptep;
}
```