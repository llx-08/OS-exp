## 1.2 实现“加载应用程序并执行”
do_execv 函数调用 load_icode（位于 kern/process/proc.c 中）来加载并解析一个处于内存中的ELF 执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好 proc_struct 结构中的成员变量 trapframe 中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的 trapframe 内容。请在实验报告中简要说明你的设计实现过程。
请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU 是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过。

---

<br>

### 1. 编码

`do_execve`中退出了当前进程的内存空间，改使用了内核的内存空间。根据函数注释，`load_icode`函数的主要工作是给用户进程建立一个能够让用户进程正常运行的用户环境，已经实现了以下功能：

1. 为当前进程创建新的mm
2. 创建一个新的PDT，并定义与mm的映射关系
3. 复制文本/数据部分，以二进制形式将BSS部件构建到进程的内存空间
4. 构造用户堆栈内存
5. 设置当前进程的mm，sr3，并设置CR3 reg=Page目录的物理地址

需要填写的部分为setup trapframe for user environment，即为用户环境设置中断返回现场，使得系统调用返回之后可以正确跳转到需要运行的程序入口，并正常运行。
根据提示易得：
```c
	// tf_cs should be USER_CS segment (see memlayout.h)
	tf->tf_cs = USER_CS;
	// tf_ds=tf_es=tf_ss should be USER_DS segment
	tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;	
	// tf_esp should be the top addr of user stack (USTACKTOP)
	tf->tf_esp = USTACKTOP;
	// tf_eip should be the entry point of this binary program (elf->e_entry)
	tf->tf_eip = elf->e_entry;
	// tf_eflags should be set to enable computer to produce Interrupt
	tf->tf_eflags |= FL_IF;
```

<br>

### 2. 描述当创建一个用户态进程并加载了应用程序后，CPU 是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条指令的整个经过。

1. 内核线程`initproc`在创建完成用户态进程`userproc`后，调用`do_wait`函数，`do_wait`函数在确认存在RUNNABLE的子进程后，调用`schedule`函数

2. schedule函数通过调用proc_run来运行新线程：
	- 设置userproc的栈指针esp为userproc->kstack + 2 * 4096，即指向userproc申请到的2页栈空间的栈顶
	- 加载userproc的页目录表。用户态的页目录表跟内核态的页目录表不同，因此要重新加载页目录表
	- 切换进程上下文，然后跳转到userproc->context.eip指向的函数，即forkret

3. `forkret`函数直接调用`forkrets`函数，`forkrets`先把栈指针指向`userproc->tf`的地址，然后跳到`__trapret`


4. `__trapret`先将`userproc->tf`的内容弹出相应寄存器，然后通过中断返回指令`iret`，跳转到userproc->tf.tf_eip指向的函数`kernel_thread_entry`

5. `kernel_thread_entry`先将`edx`保存的输入参数（NULL）压栈，然后通过`call`指令，跳转到`ebx`指向的函数`user_main`

6. `user_main`先打印用户态进程`userproc`的pid和name信息，然后调用`kernel_execve`

7. `kernel_execve`执行`exec`系统调用，CPU检测到系统调用后，会保存eflags、ss、eip等现场信息，然后根据中断号查找中断向量表，进入中断处理例程。经过一系列的函数跳转（vector128 -> __alltraps -> trap -> trap_dispatch -> syscall -> sys_exec -> do_execve），进入到exec的系统处理函数`do_execve`中

8. `do_execve`首先检查用户态虚拟内存空间是否合法，如果合法且目前只有当前进程占用，则释放虚拟内存空间，包括取消虚拟内存到物理内存的映射，释放`vma`，`mm`及页目录表占用的物理页等。

9. 调用`load_icode`函数来加载应用程序：
	- 为用户进程创建新的mm结构
	- 创建页目录表
	- 校验ELF文件的魔鬼数字是否正确
	- 创建虚拟内存空间，即往`mm`结构体添加`vma`结构
	- 分配内存，并拷贝ELF文件的各个program section到新申请的内存上
	- 为BSS section分配内存，并初始化为全0
	- 分配用户栈内存空间
	- 设置当前用户进程的mm结构、页目录表的地址及加载页目录表地址到cr3寄存器
	- 设置当前用户进程的tf结构

10. `load_icode`返回到`do_exevce`，`do_execve`设置完当前用户进程的名字为exit后返回；返回到`__alltraps`函数时进入`__trapret`函数

11. `__trapret`函数先将栈上保存的`tf`的内容弹出相应的寄存器，然后跳转到`userproc->tf.tf_eip`指向的函数，也就是应用程序的入口（`exit.c`文件中的main函数）。`__alltraps`函数先将各寄存器的值保存到`userproc->tf`中，接着将`userproc->tf`的地址压入栈后调用`tra`p函数；`trap`返回后再将`current->tf`的地址出栈，最后恢复`current->tf`的内容到各寄存器。`load_icode`函数清空了原来的`current->tf`的内容，并重新设置为应用进程的相关状态。于是当`__trapret`执行中断返回指令`iret`时，跳转到应用程序的入口，特权级也由内核态跳转到用户态。

12. 执行应用程序的第一条指令

