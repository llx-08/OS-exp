## 1.3 实现“父进程复制自己的内存空间给子进程”
创建子进程的函数 do_fork 在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range 函数（位于 kern/mm/pmm.c 中）实现的，请补充 copy_range 的实现，确保能够正确执行。
请在实验报告中简要说明如何设计实现“Copy on Write 机制”，给出概要设计，鼓励给出详细设计。
Copy-on-write（简称 COW）的基本概念是指如果有多个使用者对一个资源 A（比如内存块）进行读操作，则每个使用者只需获得一个指向同一个资源 A 的指针，就可以该资源了。若某使用者需要对这个资源 A 进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源 A 的“私有”拷贝—资源 B，可对资源 B 进行写操作。该“写操作”使用者对资源 B 的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源 A。

---

### 1. 补充 copy_range 的实现

根据函数注释，`copy_range`函数实现的功能为对需要复制的内存空间按照页为单位（copy content by page unit）从父进程的内存空间复制到子进程的内存空间中去（copy content of memory (start, end) of one process A to another process B）。

已经实现的有：
1. 返回父进程的页表地址(call get_pte to find process A's pte according to the addr start)
2. 返回子进程的页表地址，若子进程没有被分配页表，则为它分配一个页表(call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT)
3. get page from ptep, alloc a page for process B

需要实现的代码功能为replicate content of page to npage, build the map of phy addr of nage with the linear addr start。

在copy_range中对应位置填入如下内容：

```c
    // (1) find src_kvaddr: the kernel virtual address of page：找到父进程需要复制的物理页在内核地址空间中的虚拟地址
    // 该函数执行的时候使用的时内核的地址空间
    uintptr_t src_kvaddr = page2kva(page);
    // (2) find dst_kvaddr: the kernel virtual address of npage：找到子进程需要被填充的物理页的内核虚拟地址
    uintptr_t dst_kvaddr = page2kva(npage);
    // (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE：将父进程的物理页的内容复制到子进程中去
    memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
    // (4) build the map of phy addr of  nage with the linear addr start：建立子进程的物理页与虚拟页的映射关系
    ret = page_insert(to, npage, start, perm);
```

### 2. 简要说明如何设计实现“Copy on Write 机制”，给出概要设计，鼓励给出详细设计

参考网络与实验指导书，给出设计如下：

<br>

- `do_fork`：
   1. 在内存复制时将子进程和父进程的虚拟页映射上同一个物理页面，不进行实际的内存的复制
   2. 将父子进程对应的首个页表状态位置为不可写、共享
- `page_fault` ：
  1. 增加异常处理部分，判断当前的异常是否由写共享页面引起，若是，则额外申请分配一个物理页面，然后将想要写的共享页的内容复制过去，并建立共享页面与新创建的物理页面的映射关系，同时将其页表项设置成非共享的
  2. 查询原先共享的物理页面是否还是由多个其它进程共享使用的，若不是，则将对应的虚地址的页表项进行修改，置为可写、不共享

