## 1.3 实现“释放某虚地址所在的页并取消对应二级页表项的映射”函数
当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构 Page 做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。请仔细查看和理解 page_remove_pte 函数中的注释。为此，需要补全在 kern/mm/pmm.c 中的 page_remove_pte 函数。

阅读提示信息中的参考函数：
MACROs or Functions:
- `struct Page *page pte2page(*ptep)`: 
    获得*ptep指针指向的页
    get the according page from the value of a ptep
- `free_page(page)` : 
    由free_pages实现，功能是释放页
    free a page
    ```c
    //free_pages - call pmm->free_pages to free a continuous n*PAGESIZE memory 
    void
    free_pages(struct Page *base, size_t n) {
        bool intr_flag;
        local_intr_save(intr_flag);
        {
            pmm_manager->free_pages(base, n);
        }
        local_intr_restore(intr_flag);
    }
    ```
- `page_ref_dec(page)` : 
    ```c
    static inline int
    page_ref_dec(struct Page *page) {
        page->ref -= 1;
        return page->ref;
    }
    ```
    根据函数，每次调用该函数，*page指针指向的页引用ref减1（若引用为0，则该页必须被释放）
    decrease page->ref. NOTICE: ff page->ref == 0 , then this page should be free.
- `tlb_invalidate(pde_t *pgdir, uintptr_t la)` : 
    ```c
    // invalidate a TLB entry, but only if the page tables being
    // edited are the ones currently in use by the processor.
    // TLB是页表的缓冲，我们需要保证页表与TLB之间的一致性
    // 因此，在更新页表内容时候，我们需要调用tlb_invalidate()使得硬件意识到当前的tlb数据的更新可能落后与页表
    // 在X86架构中，写入TLB数据等操作是由硬件自动完成的，操作系统只需要在适当的时候使得TLB无效
    void
    tlb_invalidate(pde_t *pgdir, uintptr_t la) {
        if (rcr3() == PADDR(pgdir)) {
            invlpg((void *)la);
        }
    }
    ```
    结合函数代码与注释理解，功能为使TLB中的表项（pgdir）无效，但只有处理器当前正在使用的页表能被invalidate。
    Invalidate a TLB entry, but only if the page tables being edited are the ones currently in use by the processor.

补充`page_remove_pte`代码如下：
```c
static inline void
page_remove_pte(pde_t *pgdir, uintptr_t la, pte_t *ptep) {

    if ((*ptep & PTE_P)) //判断页表中该表项ptep是否存在
    {
        struct Page *page = pte2page(*ptep); // 获得*ptep指针（页表项）指向的页
        if (page_ref_dec(page) == 0)         // 若引用计数减一后为0，则释放该物理页
        { 
            free_page(page);
        }
        *ptep = 0;                 // 如果被多次引用，则不能释放此页，只用释放二级页表的表项，清空 PTE
        // PT is changed, so the TLB need to be invalidate
        tlb_invalidate(pgdir, la); // 将刚刚对页表进行的操作更新到TLB中
    }
}
```
